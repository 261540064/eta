
==================== STG syntax: ====================
2016-06-25 15:54:13.886638 UTC

Main.$wsum [InlPrag=[0], Occ=LoopBreaker]
  :: [MinimalBase.Int] -> GHC.Prim.Int#
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType <S,1*U>,
 Unf=OtherCon []] =
    \r srt:SRT:[] [w_s2Lg]
        case w_s2Lg of _ [Occ=Dead] {
          [] -> 0;
          : x_s2Li [Occ=Once!] xs_s2Lj [Occ=Once] ->
              case x_s2Li of _ [Occ=Dead] {
                MinimalBase.I# i1_s2Ll [Occ=Once] ->
                    case Main.$wsum xs_s2Lj of ww_s2Lm {
                      __DEFAULT -> +# [i1_s2Ll ww_s2Lm];
                    };
              };
        };
Main.sum [InlPrag=INLINE[0]]
  :: [MinimalBase.Int] -> MinimalBase.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType <S,1*U>m,
 Unf=OtherCon []] =
    \r srt:SRT:[] [w_s2Ln]
        case Main.$wsum w_s2Ln of ww_s2Lo {
          __DEFAULT -> MinimalBase.I# [ww_s2Lo];
        };
Main.map [Occ=LoopBreaker]
  :: forall a_aG3 b_aG4. (a_aG3 -> b_aG4) -> [a_aG3] -> [b_aG4]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    \r srt:SRT:[] [f_s2Lp ds_s2Lq]
        case ds_s2Lq of _ [Occ=Dead] {
          [] -> [] [];
          : x_s2Ls [Occ=Once] xs_s2Lt [Occ=Once] ->
              let {
                sat_s2Lv [Occ=Once] :: [b_aGn]
                [LclId, Str=DmdType] =
                    \u srt:SRT:[] [] Main.map f_s2Lp xs_s2Lt; } in
              let {
                sat_s2Lu [Occ=Once] :: b_aGn
                [LclId, Str=DmdType] =
                    \u srt:SRT:[] [] f_s2Lp x_s2Ls;
              } in  : [sat_s2Lu sat_s2Lv];
        };
Main.caf2 :: MinimalBase.Int -> MinimalBase.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] =
    \r srt:SRT:[] [x_s2Lw]
        case x_s2Lw of _ [Occ=Dead] {
          MinimalBase.I# i1_s2Ly [Occ=Once] ->
              case +# [i1_s2Ly 1] of sat_s2Lz {
                __DEFAULT -> MinimalBase.I# [sat_s2Lz];
              };
        };
Main.caf1 :: [MinimalBase.Int]
[GblId, Str=DmdType] =
    \u srt:SRT:[] [] MinimalBase.$wenumFromTo 1 10;
Main.caf :: [MinimalBase.Int]
[GblId, Str=DmdType] =
    \u srt:SRT:[r2J4 :-> Main.caf1] [] Main.map Main.caf2 Main.caf1;
Main.main1
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId, Arity=1, Str=DmdType <L,U>, Unf=OtherCon []] =
    \r srt:SRT:[rFZ :-> Main.caf] [s_s2LA]
        case Main.$wsum Main.caf of ww_s2LB {
          __DEFAULT ->
              case
                  __primcall main@main print_printIntzh [ww_s2LB s_s2LA]
              of
              _ [Occ=Dead]
              { (#,#) ipv_s2LE [Occ=Once] _ [Occ=Dead] ->
                    (#,#) [ipv_s2LE GHC.Tuple.()];
              };
        };
Main.main :: GHC.Types.IO ()
[GblId, Arity=1, Str=DmdType <L,U>, Unf=OtherCon []] =
    \r srt:SRT:[r2Lb :-> Main.main1] [eta_B1] Main.main1 eta_B1;
Main.main2
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId, Arity=1, Str=DmdType, Unf=OtherCon []] =
    \r srt:SRT:[rHs :-> GHC.TopHandler.runMainIO1,
                r2Lb :-> Main.main1] [eta_B1]
        GHC.TopHandler.runMainIO1 Main.main1 eta_B1;
:Main.main :: GHC.Types.IO ()
[GblId, Arity=1, Str=DmdType, Unf=OtherCon []] =
    \r srt:SRT:[r2Ld :-> Main.main2] [eta_B1] Main.main2 eta_B1;

