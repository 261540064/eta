
==================== STG syntax: ====================
2016-06-25 15:54:13.637061 UTC

MinimalBase.hundred :: MinimalBase.Int
[GblId, Caf=NoCafRefs, Str=DmdType m, Unf=OtherCon []] =
    NO_CCS MinimalBase.I#! [100];
MinimalBase.ten :: MinimalBase.Int
[GblId, Caf=NoCafRefs, Str=DmdType m, Unf=OtherCon []] =
    NO_CCS MinimalBase.I#! [10];
MinimalBase.one :: MinimalBase.Int
[GblId, Caf=NoCafRefs, Str=DmdType m, Unf=OtherCon []] =
    NO_CCS MinimalBase.I#! [1];
MinimalBase.zero :: MinimalBase.Int
[GblId, Caf=NoCafRefs, Str=DmdType m, Unf=OtherCon []] =
    NO_CCS MinimalBase.I#! [0];
MinimalBase.$wenumFromTo [InlPrag=[0]]
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> [MinimalBase.Int]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <L,U><L,U>,
 Unf=OtherCon []] =
    \r srt:SRT:[] [ww_sBR ww1_sBS]
        case ># [ww_sBR ww1_sBS] of sat_sBT {
          __DEFAULT ->
              case tagToEnum# [sat_sBT] of _ [Occ=Dead] {
                GHC.Types.False ->
                    let {
                      go_sBV [Occ=LoopBreaker] :: GHC.Prim.Int# -> [MinimalBase.Int]
                      [LclId, Arity=1, Str=DmdType <L,U>, Unf=OtherCon []] =
                          sat-only \r srt:SRT:[] [x_sBW]
                              let {
                                sat_sC1 [Occ=Once] :: [MinimalBase.Int]
                                [LclId, Str=DmdType] =
                                    \u srt:SRT:[] []
                                        case ==# [x_sBW ww1_sBS] of sat_sBY {
                                          __DEFAULT ->
                                              case tagToEnum# [sat_sBY] of _ [Occ=Dead] {
                                                GHC.Types.False ->
                                                    case +# [x_sBW 1] of sat_sC0 {
                                                      __DEFAULT -> go_sBV sat_sC0;
                                                    };
                                                GHC.Types.True -> [] [];
                                              };
                                        }; } in
                              let {
                                sat_sBX [Occ=Once] :: MinimalBase.Int
                                [LclId, Str=DmdType] =
                                    NO_CCS MinimalBase.I#! [x_sBW];
                              } in  : [sat_sBX sat_sC1];
                    } in  go_sBV ww_sBR;
                GHC.Types.True -> [] [];
              };
        };
MinimalBase.enumFromTo [InlPrag=INLINE[0]]
  :: MinimalBase.Int -> MinimalBase.Int -> [MinimalBase.Int]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S,1*U(U)><S,1*U(U)>,
 Unf=OtherCon []] =
    \r srt:SRT:[] [w_sC2 w1_sC3]
        case w_sC2 of _ [Occ=Dead] {
          MinimalBase.I# ww1_sC5 [Occ=Once] ->
              case w1_sC3 of _ [Occ=Dead] {
                MinimalBase.I# ww3_sC7 [Occ=Once] ->
                    MinimalBase.$wenumFromTo ww1_sC5 ww3_sC7;
              };
        };
MinimalBase.+
  :: MinimalBase.Int -> MinimalBase.Int -> MinimalBase.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    \r srt:SRT:[] [ds_sC8 ds1_sC9]
        case ds_sC8 of _ [Occ=Dead] {
          MinimalBase.I# i1_sCb [Occ=Once] ->
              case ds1_sC9 of _ [Occ=Dead] {
                MinimalBase.I# i2_sCd [Occ=Once] ->
                    case +# [i1_sCb i2_sCd] of sat_sCe {
                      __DEFAULT -> MinimalBase.I# [sat_sCe];
                    };
              };
        };
MinimalBase.printInt1
  :: MinimalBase.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S,1*U(U)><L,U>,
 Unf=OtherCon []] =
    \r srt:SRT:[] [ds_sCf eta_sCg]
        case ds_sCf of _ [Occ=Dead] {
          MinimalBase.I# b_sCi [Occ=Once] ->
              case
                  __primcall main@main print_printIntzh [b_sCi eta_sCg]
              of
              _ [Occ=Dead]
              { (#,#) ipv_sCl [Occ=Once] _ [Occ=Dead] ->
                    (#,#) [ipv_sCl GHC.Tuple.()];
              };
        };
MinimalBase.printInt :: MinimalBase.Int -> GHC.Types.IO ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S,1*U(U)><L,U>,
 Unf=OtherCon []] =
    \r srt:SRT:[] [eta_B2 eta_B1] MinimalBase.printInt1 eta_B2 eta_B1;
MinimalBase.I# :: GHC.Prim.Int# -> MinimalBase.Int
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType <L,U>m,
 Unf=OtherCon []] =
    \r srt:SRT:[] [eta_B1] MinimalBase.I# [eta_B1];

